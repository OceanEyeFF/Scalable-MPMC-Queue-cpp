# ObjectPool ä¼˜åŒ–è®¡åˆ’ v2.0

> åˆ›å»ºæ—¥æœŸ: 2026-01-25
> æ›´æ–°æ—¥æœŸ: 2026-01-25
> çŠ¶æ€: **å·²æ›´æ–° - æ•´åˆReviewå‘ç°**
>
> âš ï¸ **é‡è¦å˜æ›´**: æœ¬ç‰ˆæœ¬æ•´åˆäº†æ·±åº¦Reviewçš„å‘ç°ï¼Œä¿®æ­£äº†æ€§èƒ½é¢„æœŸï¼Œæ–°å¢äº†Phase 0å’Œthread_localæ–¹æ¡ˆ

## å˜æ›´æ‘˜è¦

| å˜æ›´é¡¹ | v1.0 | v2.0 |
|--------|------|------|
| Phaseåˆ’åˆ† | Phase 1-3 | **Phase 0** (æ–°å¢) + Phase 1-3 |
| Phase 1æ–¹æ¡ˆ | ä»…Per-Pool Map | **åŒè½¨åˆ¶**: Mapæ–¹æ¡ˆ / thread_localæ–¹æ¡ˆ |
| æ€§èƒ½é¢„æœŸ | 5-10ns | **30-50ns** (Map) æˆ– **5-10ns** (TLS) |
| å‘½ä¸­ç‡é¢„æœŸ | ~50% | **20-40%** (åŸºäºLSCQåˆ†æ) |
| æµ‹è¯•å·¥å…· | ASan/TSan | **MSVC CRT Debug Heap** (Windowsé€‚é…) |
| é—­é”æœºåˆ¶ | æ— è¶…æ—¶ | **1ç§’è¶…æ—¶ä¿æŠ¤** |

---

## èƒŒæ™¯

å½“å‰ ObjectPool å®ç°é‡‡ç”¨åˆ†ç‰‡ + mutex çš„è®¾è®¡ï¼Œæ¯æ¬¡ Get/Put éƒ½éœ€è¦åŠ é”ã€‚
å‚è€ƒ Golang sync.Pool çš„è®¾è®¡ç†å¿µï¼Œè®¡åˆ’é€šè¿‡æ¸è¿›å¼è¿­ä»£ä¼˜åŒ–æ€§èƒ½ã€‚

## å½“å‰å®ç°åˆ†æ

```cpp
// å½“å‰æ¶æ„
template <class T>
class ObjectPool {
    struct Shard {
        mutable std::mutex mutex;
        std::vector<std::unique_ptr<T>> objects;
    };

    std::vector<Shard> shards_;  // åˆ†ç‰‡ï¼Œå‡å°‘é”ç«äº‰
    Factory factory_;
};

// Get/Put æµç¨‹
// 1. hash(thread_id) â†’ é€‰æ‹©åˆ†ç‰‡
// 2. åŠ é” â†’ æ“ä½œ â†’ è§£é”
// 3. å·¥ä½œçªƒå–ï¼ˆtry_lock å…¶ä»–åˆ†ç‰‡ï¼‰
```

**æ€§èƒ½ç“¶é¢ˆ**: æ¯æ¬¡æ“ä½œéƒ½éœ€è¦ mutex åŠ é”ï¼Œçƒ­è·¯å¾„å¼€é”€ ~50-100ns

---

## æ¸è¿›å¼ä¼˜åŒ–è®¡åˆ’

### Phase 0: åŸºå‡†æ•°æ®æ”¶é›† ğŸ†•

> âš ï¸ **è¿™æ˜¯æœ€å…³é”®çš„Phaseï¼** å¿…é¡»åœ¨å¼€å§‹ä»»ä½•ä¼˜åŒ–å‰å®Œæˆã€‚

**ç›®æ ‡**: ç”¨å®æµ‹æ•°æ®éªŒè¯å‡è®¾ï¼Œå†³å®šåç»­æ–¹æ¡ˆ

**æµ‹è¯•å†…å®¹**:

1. **ç»„ä»¶å¼€é”€å¾®åŸºå‡†æµ‹è¯•** (`benchmark_components.cpp`)
   - `shared_mutex` è¯»é”å¼€é”€
   - `unordered_map::find()` å¼€é”€
   - `std::thread::id` è·å–å’Œå“ˆå¸Œå¼€é”€
   - `thread_local` è®¿é—®å¼€é”€
   - åŸå­æ“ä½œå¼€é”€

2. **LSCQä½¿ç”¨æ¨¡å¼åˆ†æ** (`test_lscq_usage_pattern.cpp`)
   - Get/Put è°ƒç”¨æ¯”ä¾‹
   - åŒçº¿ç¨‹ Putâ†’Get é—´éš”æ—¶é—´
   - æ½œåœ¨æœ¬åœ°ç¼“å­˜å‘½ä¸­ç‡

**å†³ç­–é˜ˆå€¼**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 0 å†³ç­–çŸ©é˜µ                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¦‚æœ Mapçƒ­è·¯å¾„ < 25ns AND å‘½ä¸­ç‡ > 40%                       â”‚
â”‚   â†’ ä½¿ç”¨ Per-Pool Map æ–¹æ¡ˆï¼ˆç®€å•å®‰å…¨ï¼‰                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¦‚æœ Mapçƒ­è·¯å¾„ > 40ns OR å‘½ä¸­ç‡ < 30%                        â”‚
â”‚   â†’ ä½¿ç”¨ thread_local æ··åˆæ–¹æ¡ˆï¼ˆé«˜æ€§èƒ½ï¼‰                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å…¶ä»–æƒ…å†µ                                                     â”‚
â”‚   â†’ è¯„ä¼°é£é™©åé€‰æ‹©ï¼Œå€¾å‘äº thread_local æ–¹æ¡ˆ                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**é¢„è®¡å·¥ä½œé‡**: 1å¤©

---

### Phase 1: å•å¯¹è±¡æœ¬åœ°ç¼“å­˜ï¼ˆåŒè½¨åˆ¶ï¼‰

**ç›®æ ‡**: ä¸ºæ¯ä¸ªçº¿ç¨‹æ·»åŠ å•ä¸ªç§æœ‰å¯¹è±¡æ§½ä½ï¼Œçƒ­è·¯å¾„å°½å¯èƒ½æ— é”

æ ¹æ® Phase 0 çš„æµ‹è¯•ç»“æœï¼Œé€‰æ‹©ä»¥ä¸‹æ–¹æ¡ˆä¹‹ä¸€ï¼š

#### æ–¹æ¡ˆA: Per-Pool Mapï¼ˆå®‰å…¨ä¼˜å…ˆï¼‰

**é€‚ç”¨æ¡ä»¶**: Mapçƒ­è·¯å¾„ < 25ns

**è®¾è®¡**:
```cpp
struct LocalCache {
    pointer private_obj = nullptr;  // å•ä¸ªç§æœ‰å¯¹è±¡
};

// Per-Pool ç¼“å­˜æ˜ å°„ï¼ˆé¿å…å…¨å±€ TLS é—®é¢˜ï¼‰
std::shared_mutex cache_mutex_;
std::unordered_map<std::thread::id, LocalCache> caches_;
```

**Get æµç¨‹**:
```
1. [çƒ­è·¯å¾„] shared_lock + map.find() â†’ æ£€æŸ¥ private_obj â†’ éç©ºåˆ™è¿”å›
2. [æ¸©è·¯å¾„] ä»å…±äº«åˆ†ç‰‡è·å–
3. [å†·è·¯å¾„] å·¥ä½œçªƒå– / æ–°å»º
```

**Put æµç¨‹**:
```
1. [çƒ­è·¯å¾„] shared_lock + map.find() â†’ private_obj ä¸ºç©º â†’ å­˜å…¥
2. [æ¸©è·¯å¾„] private_obj å·²æ»¡ â†’ æ”¾å…¥å…±äº«åˆ†ç‰‡
```

**æ€§èƒ½é¢„æœŸ** (ä¿®æ­£å):
- çƒ­è·¯å¾„: **~30-50ns**ï¼ˆå« shared_mutex è¯»é” + map æŸ¥æ‰¾ï¼‰
- å‘½ä¸­ç‡: ~30-40%

**ä¼˜ç‚¹**:
- âœ… Pool å®Œå…¨æ§åˆ¶ç¼“å­˜ç”Ÿå‘½å‘¨æœŸ
- âœ… æ— å…¨å±€ TLSï¼Œæ— è·¨ Pool å¹²æ‰°
- âœ… ææ„æ—¶å¯å®‰å…¨éå†æ‰€æœ‰ç¼“å­˜

**ç¼ºç‚¹**:
- âš ï¸ çƒ­è·¯å¾„ä»æœ‰é”å¼€é”€
- âš ï¸ ä¼˜åŒ–æ•ˆæœæœ‰é™ï¼ˆvs baseline 50-100nsï¼‰

---

#### æ–¹æ¡ˆB: thread_local æ··åˆæ–¹æ¡ˆï¼ˆæ€§èƒ½ä¼˜å…ˆï¼‰ğŸ†•

**é€‚ç”¨æ¡ä»¶**: Mapçƒ­è·¯å¾„ > 40ns æˆ–éœ€è¦æè‡´æ€§èƒ½

**è®¾è®¡**:
```cpp
template <class T>
class ObjectPool {
    struct LocalCache {
        pointer private_obj = nullptr;
        ObjectPool* owner = nullptr;  // éªŒè¯æŒ‡é’ˆæœ‰æ•ˆæ€§
    };

    // å¿«è·¯å¾„ï¼šthread_localï¼ˆçœŸæ­£çš„5-10nsï¼‰
    static thread_local LocalCache tls_fast_cache_;

    // å®‰å…¨ä¿éšœï¼šæ³¨å†Œè¡¨ï¼ˆä»…ç”¨äºææ„æ¸…ç†ï¼‰
    std::mutex registry_mutex_;
    std::vector<LocalCache*> registered_caches_;

    // é—­é”æœºåˆ¶
    std::atomic<bool> closing_{false};
    std::atomic<int> active_ops_{0};
};
```

**Get æµç¨‹**:
```cpp
pointer Get() {
    // 0. é—­é”æ£€æŸ¥
    if (closing_.load(std::memory_order_acquire)) {
        return factory_();
    }
    OpGuard guard(active_ops_);

    // 1. [æœ€çƒ­è·¯å¾„] ç›´æ¥è®¿é—® thread_localï¼ˆ5-10nsï¼‰
    if (tls_fast_cache_.owner == this && tls_fast_cache_.private_obj) {
        pointer obj = tls_fast_cache_.private_obj;
        tls_fast_cache_.private_obj = nullptr;
        return obj;
    }

    // 2. [é¦–æ¬¡è®¿é—®] æ³¨å†Œåˆ° registryï¼ˆä»…ä¸€æ¬¡ï¼‰
    if (tls_fast_cache_.owner != this) {
        tls_fast_cache_.owner = this;
        std::lock_guard lock(registry_mutex_);
        registered_caches_.push_back(&tls_fast_cache_);
    }

    // 3. [æ…¢è·¯å¾„] ä»å…±äº«åˆ†ç‰‡è·å–
    return GetFromShards();
}
```

**Put æµç¨‹**:
```cpp
void Put(pointer obj) {
    if (!obj) return;

    // 0. é—­é”æ£€æŸ¥
    if (closing_.load(std::memory_order_acquire)) {
        delete obj;
        return;
    }
    OpGuard guard(active_ops_);

    // 1. [æœ€çƒ­è·¯å¾„] å­˜å…¥ thread_local
    if (tls_fast_cache_.owner == this && !tls_fast_cache_.private_obj) {
        tls_fast_cache_.private_obj = obj;
        return;
    }

    // 2. [æ…¢è·¯å¾„] æ”¾å…¥å…±äº«åˆ†ç‰‡
    PutToShards(obj);
}
```

**æ€§èƒ½é¢„æœŸ**:
- çƒ­è·¯å¾„: **~5-10ns**ï¼ˆä»…æŒ‡é’ˆæ£€æŸ¥ï¼Œæ— é”æ— mapï¼‰
- å‘½ä¸­ç‡: ~30-40%ï¼ˆä¸æ–¹æ¡ˆAç›¸åŒï¼‰

**ä¼˜ç‚¹**:
- âœ… çœŸæ­£çš„æ— é”çƒ­è·¯å¾„
- âœ… æ€§èƒ½æå‡æ˜¾è‘—ï¼ˆ5-10x vs baselineï¼‰
- âœ… é€šè¿‡ registry ä¿è¯ææ„å®‰å…¨

**ç¼ºç‚¹**:
- âš ï¸ å®ç°å¤æ‚åº¦è¾ƒé«˜
- âš ï¸ éœ€è¦ç‰¹åˆ«æ³¨æ„ç”Ÿå‘½å‘¨æœŸç®¡ç†
- âš ï¸ å…¨å±€ TLS éœ€è¦ owner éªŒè¯

---

### Phase 2: å¤šå¯¹è±¡æœ¬åœ°ç¼“å­˜

**ç›®æ ‡**: æ‰©å±•æœ¬åœ°ç¼“å­˜å®¹é‡ï¼Œæé«˜å‘½ä¸­ç‡

**è®¾è®¡**:
```cpp
struct alignas(64) LocalCache {  // cache line å¯¹é½
    static constexpr std::size_t kBatchSize = 8;  // å¾… Phase 0 å®æµ‹è°ƒä¼˜

    pointer private_obj = nullptr;           // æœ€å¿«è·¯å¾„
    pointer local_batch[kBatchSize] = {};    // æœ¬åœ°æ‰¹é‡
    std::size_t local_count = 0;
    ObjectPool* owner = nullptr;             // æ–¹æ¡ˆBä¸“ç”¨
};
```

**Get æµç¨‹**:
```
1. [æœ€çƒ­] private_obj éç©º â†’ è¿”å›
2. [æ¬¡çƒ­] local_batch æœ‰å¯¹è±¡ â†’ pop å¹¶è¿”å›
3. [æ¸©] ä»å…±äº«åˆ†ç‰‡æ‰¹é‡è·å–åˆ° local_batch
4. [å†·] å·¥ä½œçªƒå– / æ–°å»º
```

**Put æµç¨‹**:
```
1. [æœ€çƒ­] private_obj ä¸ºç©º â†’ å­˜å…¥
2. [æ¬¡çƒ­] local_batch æœªæ»¡ â†’ push
3. [æ¸©] local_batch æ»¡ â†’ æ‰¹é‡è½¬ç§»åˆ°å…±äº«åˆ†ç‰‡
```

**é¢„æœŸæ”¶ç›Š**:
- çƒ­è·¯å¾„å‘½ä¸­ç‡: ~60-80%
- å‡å°‘å…±äº«åˆ†ç‰‡è®¿é—®é¢‘ç‡

**æ³¨æ„äº‹é¡¹**:
- âš ï¸ kBatchSize éœ€è¦æ ¹æ® Phase 0 çš„ LSCQ ä½¿ç”¨æ¨¡å¼åˆ†æç»“æœè°ƒä¼˜
- âš ï¸ è¿‡å¤§çš„æ‰¹é‡å¯èƒ½å¯¼è‡´å†…å­˜æµªè´¹
- âš ï¸ LSCQ dequeue åœºæ™¯ Put å¤šäº Getï¼Œéœ€è¦è€ƒè™‘ä¸å¯¹ç§°æƒ…å†µ

---

### Phase 3: TLS ç”Ÿå‘½å‘¨æœŸæ”¹è¿›

**ç›®æ ‡**: è§£å†³ TLS ç”Ÿå‘½å‘¨æœŸé—®é¢˜ï¼Œç¡®ä¿å®‰å…¨æ€§

**æ ¸å¿ƒçŸ›ç›¾**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TLS ç”Ÿå‘½å‘¨æœŸ = çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸ                                  â”‚
â”‚ Pool ç”Ÿå‘½å‘¨æœŸ = Pool å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ                            â”‚
â”‚                                                             â”‚
â”‚ å¯èƒ½å‡ºç°ï¼š                                                   â”‚
â”‚ 1. Pool å…ˆé”€æ¯ â†’ çº¿ç¨‹çš„ TLS æŒ‡å‘å·²é‡Šæ”¾å†…å­˜ (UAF)            â”‚
â”‚ 2. çº¿ç¨‹å…ˆé€€å‡º â†’ Pool æŒæœ‰æ‚¬ç©ºæŒ‡é’ˆï¼ˆå¯æ¥å—ï¼‰                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**EBR è¸©è¿‡çš„å‘**:
- å…¨å±€ TLS è¢«å¤šä¸ª Pool å®ä¾‹å…±äº«
- ææ„æ—¶åªèƒ½æ¸…ç†å½“å‰çº¿ç¨‹çš„ TLS
- å…¶ä»–çº¿ç¨‹çš„ TLS ä»æŒ‡å‘å·²é‡Šæ”¾å†…å­˜

**è§£å†³æ–¹æ¡ˆ: é—­é” + è¶…æ—¶ä¿æŠ¤**:

```cpp
// RAII æ“ä½œè®¡æ•°å™¨
struct OpGuard {
    std::atomic<int>& counter;

    explicit OpGuard(std::atomic<int>& c) : counter(c) {
        counter.fetch_add(1, std::memory_order_acquire);
    }

    ~OpGuard() {
        counter.fetch_sub(1, std::memory_order_release);
    }

    OpGuard(const OpGuard&) = delete;
    OpGuard& operator=(const OpGuard&) = delete;
};

// ææ„å‡½æ•°ï¼ˆå¸¦è¶…æ—¶ä¿æŠ¤ï¼‰
~ObjectPool() {
    // 1. æ ‡è®°å…³é—­
    closing_.store(true, std::memory_order_release);

    // 2. ç­‰å¾…æ‰€æœ‰æ“ä½œå®Œæˆï¼ˆå¸¦è¶…æ—¶ï¼‰
    constexpr auto kTimeout = std::chrono::seconds(1);
    auto deadline = std::chrono::steady_clock::now() + kTimeout;

    while (active_ops_.load(std::memory_order_acquire) > 0) {
        if (std::chrono::steady_clock::now() >= deadline) {
            // è¶…æ—¶è­¦å‘Šï¼ˆç”Ÿäº§ç¯å¢ƒåº”è®°å½•æ—¥å¿—ï¼‰
            #ifdef _DEBUG
            std::cerr << "ObjectPool: destruction timeout, forcing cleanup\n";
            #endif
            break;
        }
        std::this_thread::yield();
    }

    // 3. æ¸…ç†æœ¬åœ°ç¼“å­˜
    // æ–¹æ¡ˆA: éå† caches_ map
    // æ–¹æ¡ˆB: éå† registered_caches_
    CleanupLocalCaches();

    // 4. å…±äº«åˆ†ç‰‡è‡ªåŠ¨æ¸…ç†ï¼ˆRAIIï¼‰
}
```

**æ¸…ç†é€»è¾‘ï¼ˆæ–¹æ¡ˆBï¼‰**:
```cpp
void CleanupLocalCaches() {
    std::lock_guard lock(registry_mutex_);
    for (LocalCache* cache : registered_caches_) {
        if (cache->owner == this) {
            if (cache->private_obj) {
                delete cache->private_obj;
                cache->private_obj = nullptr;
            }
            // Phase 2: æ¸…ç† local_batch
            for (std::size_t i = 0; i < cache->local_count; ++i) {
                delete cache->local_batch[i];
            }
            cache->local_count = 0;
            cache->owner = nullptr;  // æ ‡è®°ä¸ºæ— æ•ˆ
        }
    }
    registered_caches_.clear();
}
```

**ä¼˜ç‚¹**:
- âœ… Pool å®Œå…¨æ§åˆ¶ç¼“å­˜ç”Ÿå‘½å‘¨æœŸ
- âœ… è¶…æ—¶ä¿æŠ¤é˜²æ­¢ææ„æ— é™ç­‰å¾…
- âœ… æ–¹æ¡ˆB é€šè¿‡ owner éªŒè¯é˜²æ­¢ UAF

**ç¼ºç‚¹**:
- âš ï¸ æ¯æ¬¡ Get/Put æœ‰åŸå­æ“ä½œå¼€é”€ï¼ˆ~10-15nsï¼‰
- âš ï¸ è¶…æ—¶å¼ºåˆ¶æ¸…ç†å¯èƒ½å¯¼è‡´å°æ¦‚ç‡å†…å­˜æ³„æ¼

---

## å®æ–½æ—¶é—´çº¿

| Phase | é¢„è®¡å·¥ä½œé‡ | ä¼˜å…ˆçº§ | ä¾èµ– |
|-------|-----------|--------|------|
| Phase 0 | 1 å¤© | **æœ€é«˜** | æ—  |
| Phase 1 | 1-2 å¤© | é«˜ | Phase 0 å†³ç­– |
| Phase 2 | 1 å¤© | ä¸­ | Phase 1 |
| Phase 3 | 1-2 å¤© | é«˜ï¼ˆå®‰å…¨æ€§ï¼‰ | Phase 1 |

## æµ‹è¯•éªŒè¯

æ¯ä¸ª Phase å®Œæˆåéœ€è¦éªŒè¯ï¼š

### 1. åŠŸèƒ½æ­£ç¡®æ€§
- å•çº¿ç¨‹ Get/Put æµ‹è¯•
- å¤šçº¿ç¨‹å¹¶å‘æµ‹è¯•
- LSCQ é›†æˆæµ‹è¯•

### 2. å†…å­˜å®‰å…¨ï¼ˆWindows/MSVC é€‚é…ï¼‰ğŸ†•

> âš ï¸ Windows ç¯å¢ƒä¸æ”¯æŒ AddressSanitizer/ThreadSanitizer

**æ›¿ä»£æ–¹æ¡ˆ**:
- **CRT Debug Heap**: æ£€æµ‹å†…å­˜æ³„æ¼
  ```cpp
  #define _CRTDBG_MAP_ALLOC
  #include <crtdbg.h>
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
  ```
- **VS Diagnostic Tools**: ç›‘æ§å†…å­˜ä½¿ç”¨æ›²çº¿
- **Application Verifier**: æ£€æµ‹å †æŸå
- **è‡ªå®šä¹‰è°ƒè¯•è®¡æ•°å™¨**: è¿½è¸ª Get/Put é…å¯¹

### 3. æ€§èƒ½å¯¹æ¯”

| åœºæ™¯ | Baseline | Phase 1 (Map) | Phase 1 (TLS) | Phase 2 | Phase 3 |
|------|----------|---------------|---------------|---------|---------|
| å•çº¿ç¨‹çƒ­è·¯å¾„ | 50-100ns | 30-50ns | **5-10ns** | 5-10ns | 15-25ns |
| 4çº¿ç¨‹å¹¶å‘ | 80-150ns | 50-100ns | 20-40ns | 15-30ns | 25-45ns |
| å‘½ä¸­ç‡ | N/A | 30-40% | 30-40% | 60-80% | 60-80% |

### 4. ææ„å®‰å…¨
- Pool å…ˆäºçº¿ç¨‹é”€æ¯ï¼ˆå±é™©åœºæ™¯ï¼‰
- çº¿ç¨‹å…ˆäº Pool é€€å‡ºï¼ˆå®‰å…¨åœºæ™¯ï¼‰
- å¹¶å‘ææ„åœºæ™¯
- å¤š Pool å…±å­˜åœºæ™¯

---

## å…³é”®é£é™©ä¸ç¼“è§£æªæ–½

| é£é™© | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|---------|
| MapæŸ¥æ‰¾å¼€é”€æŠµæ¶ˆä¼˜åŒ– | Phase 1 æ•ˆæœä¸è¾¾æ ‡ | Phase 0 å®æµ‹ï¼Œå¿…è¦æ—¶åˆ‡æ¢ TLS æ–¹æ¡ˆ |
| TLS ç”Ÿå‘½å‘¨æœŸ UAF | ç¨‹åºå´©æºƒ | owner éªŒè¯ + é—­é”æœºåˆ¶ |
| ææ„æ— é™ç­‰å¾… | ç¨‹åºæŒ‚èµ· | 1ç§’è¶…æ—¶å¼ºåˆ¶æ¸…ç† |
| å‘½ä¸­ç‡è¿‡ä½ | ä¼˜åŒ–æ•ˆæœæœ‰é™ | Phase 2 æ‰©å¤§ç¼“å­˜å®¹é‡ |
| Windows shared_mutex æ€§èƒ½å·® | çƒ­è·¯å¾„å¼€é”€å¢åŠ  | ä½¿ç”¨ TLS æ–¹æ¡ˆæ›¿ä»£ |

---

## å‚è€ƒèµ„æ–™

- Golang sync.Pool å®ç°: https://github.com/golang/go/blob/master/src/sync/pool.go
- C++ TLS æœ€ä½³å®è·µ
- é¡¹ç›® EBR å®ç°çš„æ•™è®­: `include/lscq/ebr.hpp`
- Review æŠ¥å‘Š: `docs/ObjectPool-Optimization-Review.md`
- æµ‹è¯•è®¡åˆ’: `docs/ObjectPool-Testing-Plan.md`

---

*æ–‡æ¡£ç‰ˆæœ¬: 2.0*
*æ›´æ–°æ—¥æœŸ: 2026-01-25*
*ä¸‹æ¬¡Review: Phase 0 å®Œæˆå*
