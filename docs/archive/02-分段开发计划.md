# LSCQ C++ 分段开发计划

> 基于敏捷开发理念的迭代式实现路线图
>
> 文档版本: v1.0
> 创建日期: 2026-01-17
> 作者: Scaleable-MPMC-Queue-cpp Team

---

[TOC]

---

## 1. 开发理念

### 1.1 核心原则

1. **迭代开发**: 分阶段实现，每个阶段都有可运行的deliverable
2. **测试驱动**: 每个阶段都包含对应的单元测试和benchmark
3. **先正确后快速**: 先保证算法正确性，再进行性能优化
4. **平台渐进**: 先在x86-64验证，再扩展到其他平台

### 1.2 风险管理

- **技术风险**: CAS2可移植性、内存回收正确性
- **应对策略**: 早期原型验证、充分的单元测试、多平台CI

---

## 2. 开发阶段划分

整个项目分为**6个主要阶段** + **1个持续阶段**:

```
Phase 0: 项目初始化 [已完成]
   ├─ 技术调研与文档撰写
   └─ 开发计划制定

Phase 1: 基础设施搭建 (1-2周)
   ├─ 项目结构
   ├─ 构建系统
   ├─ 测试框架
   └─ CAS2检测机制

Phase 2: NCQ实现与验证 (1周)
   ├─ NCQ算法实现
   ├─ 正确性测试
   └─ 基础benchmark

Phase 3: SCQ核心实现 (2-3周)
   ├─ 单字宽CAS版本
   ├─ Threshold机制
   ├─ Cache remap
   └─ Catchup优化

Phase 4: 双字宽CAS扩展 (1周)
   ├─ SCQP实现
   ├─ Threshold调整
   └─ 性能对比

Phase 5: LSCQ无界队列 (2周)
   ├─ 链表结构
   ├─ 内存回收
   └─ 压力测试

Phase 6: 优化与多平台支持 (2-3周)
   ├─ 性能调优
   ├─ ARM64移植
   ├─ Fallback方案
   └─ 文档完善

Phase 7: 持续维护 (持续)
   ├─ Bug修复
   ├─ 性能监控
   └─ 社区反馈
```

**总预估时间**: 10-13周

---

## 3. Phase 1: 基础设施搭建

### 3.1 目标

建立项目的基础骨架，为后续开发铺平道路。

### 3.2 任务清单

#### 3.2.1 项目结构设计

```
Scaleable-MPMC-Queue-cpp/
├── include/
│   └── lscq/
│       ├── config.hpp           # 配置宏定义
│       ├── platform.hpp         # 平台检测
│       ├── cas2.hpp             # CAS2抽象层
│       ├── entry.hpp            # Entry结构
│       ├── ncq.hpp              # NCQ声明
│       ├── scq.hpp              # SCQ声明
│       ├── scqp.hpp             # SCQP声明
│       └── lscq.hpp             # LSCQ声明
├── src/
│   ├── ncq.cpp
│   ├── scq.cpp
│   ├── scqp.cpp
│   └── lscq.cpp
├── tests/
│   ├── unit/
│   │   ├── test_cas2.cpp
│   │   ├── test_ncq.cpp
│   │   ├── test_scq.cpp
│   │   └── test_lscq.cpp
│   └── integration/
│       └── test_mpmc.cpp
├── benchmark/
│   ├── benchmark_ncq.cpp
│   ├── benchmark_scq.cpp
│   ├── benchmark_compare.cpp
│   └── utils/
│       └── benchmark_helpers.hpp
├── examples/
│   ├── simple_usage.cpp
│   └── object_pool.cpp
├── docs/
│   ├── 01-技术实现思路.md
│   ├── 02-分段开发计划.md
│   ├── 03-性能验证方案.md
│   └── API.md
├── CMakeLists.txt
├── .github/
│   └── workflows/
│       └── ci.yml
└── README.md
```

#### 3.2.2 构建系统配置

**CMake配置要点**:

```cmake
cmake_minimum_required(VERSION 3.15)
project(lscq VERSION 1.0.0 LANGUAGES CXX)

# C++17标准
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 编译器检测
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    # GCC/Clang特定选项
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -march=native")
elseif(MSVC)
    # MSVC特定选项
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4")
endif()

# 选项
option(LSCQ_BUILD_TESTS "Build tests" ON)
option(LSCQ_BUILD_BENCHMARKS "Build benchmarks" ON)
option(LSCQ_ENABLE_CAS2 "Enable double-width CAS" ON)
option(LSCQ_ENABLE_SANITIZERS "Enable sanitizers" OFF)

# 依赖: Google Test
if(LSCQ_BUILD_TESTS)
    include(FetchContent)
    FetchContent_Declare(
        googletest
        GIT_REPOSITORY https://github.com/google/googletest.git
        GIT_TAG release-1.12.1
    )
    FetchContent_MakeAvailable(googletest)
endif()

# 依赖: Google Benchmark
if(LSCQ_BUILD_BENCHMARKS)
    FetchContent_Declare(
        benchmark
        GIT_REPOSITORY https://github.com/google/benchmark.git
        GIT_TAG v1.8.0
    )
    FetchContent_MakeAvailable(benchmark)
endif()

# 主库
add_library(lscq INTERFACE)
target_include_directories(lscq INTERFACE include/)

# Sanitizers支持
if(LSCQ_ENABLE_SANITIZERS)
    target_compile_options(lscq INTERFACE
        -fsanitize=thread
        -fsanitize=address
        -fsanitize=undefined
    )
    target_link_options(lscq INTERFACE
        -fsanitize=thread
        -fsanitize=address
        -fsanitize=undefined
    )
endif()
```

#### 3.2.3 CAS2检测与抽象

**config.hpp** - 平台能力检测:

```cpp
#ifndef LSCQ_CONFIG_HPP
#define LSCQ_CONFIG_HPP

// 检测CPU架构
#if defined(__x86_64__) || defined(_M_X64)
    #define LSCQ_ARCH_X86_64 1
#elif defined(__aarch64__) || defined(_M_ARM64)
    #define LSCQ_ARCH_ARM64 1
#elif defined(__powerpc64__)
    #define LSCQ_ARCH_PPC64 1
#else
    #define LSCQ_ARCH_UNKNOWN 1
#endif

// 检测编译器
#if defined(__GNUC__) || defined(__clang__)
    #define LSCQ_COMPILER_GCC_LIKE 1
#elif defined(_MSC_VER)
    #define LSCQ_COMPILER_MSVC 1
#endif

// 检测CAS2支持 (编译时)
#if defined(LSCQ_ARCH_X86_64) && defined(LSCQ_COMPILER_GCC_LIKE)
    #define LSCQ_HAS_CAS2_COMPILE_TIME 1
#elif defined(LSCQ_ARCH_ARM64) && (__ARM_ARCH >= 8)
    #define LSCQ_HAS_CAS2_COMPILE_TIME 1
#else
    #define LSCQ_HAS_CAS2_COMPILE_TIME 0
#endif

// 配置参数
namespace lscq {
namespace config {

constexpr size_t DEFAULT_SCQSIZE = 1 << 16;  // 65536
constexpr size_t DEFAULT_QSIZE = DEFAULT_SCQSIZE / 2;  // 32768

}  // namespace config
}  // namespace lscq

#endif  // LSCQ_CONFIG_HPP
```

**cas2.hpp** - CAS2运行时检测:

```cpp
#ifndef LSCQ_CAS2_HPP
#define LSCQ_CAS2_HPP

#include <cstdint>
#include <atomic>

namespace lscq {

// 运行时检测CAS2支持
bool has_cas2_support();

// Entry结构 (用于CAS2)
struct alignas(16) Entry {
    uint64_t cycle_flags;
    uint64_t index_or_ptr;

    bool operator==(const Entry& other) const {
        return cycle_flags == other.cycle_flags &&
               index_or_ptr == other.index_or_ptr;
    }
};

#if LSCQ_HAS_CAS2_COMPILE_TIME

// CAS2实现 (x86-64)
#ifdef LSCQ_ARCH_X86_64
inline bool cas2(Entry* ptr, Entry& expected, Entry& desired) {
    __int128 exp = *reinterpret_cast<__int128*>(&expected);
    __int128 des = *reinterpret_cast<__int128*>(&desired);

    bool success = __sync_bool_compare_and_swap_16(
        reinterpret_cast<__int128*>(ptr), exp, des
    );

    if (!success) {
        expected = *ptr;
    }
    return success;
}
#endif

// CAS2实现 (ARM64)
#ifdef LSCQ_ARCH_ARM64
inline bool cas2(Entry* ptr, Entry& expected, Entry& desired) {
    // 使用CASP指令的C++封装
    std::atomic<Entry>* atomic_ptr = reinterpret_cast<std::atomic<Entry>*>(ptr);
    return atomic_ptr->compare_exchange_strong(
        expected, desired,
        std::memory_order_acq_rel,
        std::memory_order_acquire
    );
}
#endif

#else  // Fallback: 使用锁

#include <mutex>

class CAS2Fallback {
    mutable std::mutex mutex_;

public:
    bool cas2(Entry* ptr, Entry& expected, Entry& desired) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (*ptr == expected) {
            *ptr = desired;
            return true;
        }
        expected = *ptr;
        return false;
    }
};

extern CAS2Fallback g_cas2_fallback;

inline bool cas2(Entry* ptr, Entry& expected, Entry& desired) {
    return g_cas2_fallback.cas2(ptr, expected, desired);
}

#endif

}  // namespace lscq

#endif  // LSCQ_CAS2_HPP
```

#### 3.2.4 测试框架搭建

**test_cas2.cpp** - CAS2功能验证:

```cpp
#include <gtest/gtest.h>
#include "lscq/cas2.hpp"
#include <thread>
#include <vector>

using namespace lscq;

TEST(CAS2Test, BasicOperation) {
    alignas(16) Entry entry{0, 0};
    Entry expected{0, 0};
    Entry desired{1, 42};

    bool success = cas2(&entry, expected, desired);
    EXPECT_TRUE(success);
    EXPECT_EQ(entry.cycle_flags, 1);
    EXPECT_EQ(entry.index_or_ptr, 42);
}

TEST(CAS2Test, FailedOperation) {
    alignas(16) Entry entry{1, 42};
    Entry expected{0, 0};  // 不匹配
    Entry desired{2, 100};

    bool success = cas2(&entry, expected, desired);
    EXPECT_FALSE(success);
    EXPECT_EQ(expected.cycle_flags, 1);  // expected被更新为实际值
    EXPECT_EQ(expected.index_or_ptr, 42);
}

TEST(CAS2Test, Concurrent) {
    constexpr int NUM_THREADS = 8;
    constexpr int ITERATIONS = 10000;

    alignas(16) Entry entry{0, 0};
    std::atomic<int> success_count{0};

    auto worker = [&]() {
        for (int i = 0; i < ITERATIONS; ++i) {
            Entry expected = entry;
            Entry desired{expected.cycle_flags + 1, expected.index_or_ptr + 1};

            if (cas2(&entry, expected, desired)) {
                success_count.fetch_add(1);
            }
        }
    };

    std::vector<std::thread> threads;
    for (int i = 0; i < NUM_THREADS; ++i) {
        threads.emplace_back(worker);
    }

    for (auto& t : threads) {
        t.join();
    }

    // 验证原子性：成功次数应等于最终cycle值
    EXPECT_EQ(success_count.load(), entry.cycle_flags);
}

TEST(CAS2Test, RuntimeDetection) {
    bool has_support = has_cas2_support();

#if LSCQ_HAS_CAS2_COMPILE_TIME
    EXPECT_TRUE(has_support);
#else
    // Fallback模式，总是返回true (使用锁实现)
    EXPECT_TRUE(has_support);
#endif
}
```

### 3.3 可交付成果 (Deliverables)

- [ ] 完整的项目目录结构
- [ ] 可编译通过的CMake配置
- [ ] CAS2抽象层及fallback机制
- [ ] 运行时检测函数实现
- [ ] CAS2单元测试全部通过
- [ ] CI/CD pipeline基础配置

### 3.4 验收标准

1. ✅ `cmake .. && make` 编译成功
2. ✅ 所有CAS2测试通过 (包括并发测试)
3. ✅ 代码覆盖率 > 80%
4. ✅ 无内存泄漏 (valgrind检测)
5. ✅ ThreadSanitizer无警告

### 3.5 风险与应对

| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|----------|
| CAS2在旧CPU上不支持 | 低 | 中 | 提供fallback方案 |
| CMake配置复杂 | 低 | 低 | 参考成熟项目 |
| Google Test依赖问题 | 中 | 低 | 使用FetchContent自动下载 |

---

## 4. Phase 2: NCQ实现与验证

### 4.1 目标

实现论文中的NCQ (Naive Circular Queue)算法，作为后续SCQ的baseline和验证参考。

### 4.2 为什么先实现NCQ？

1. **复杂度递进**: NCQ比SCQ简单，有助于理解ring buffer基础
2. **正确性参考**: NCQ算法相对简单，更容易验证正确性
3. **性能基线**: 可以与M&S Queue对比，验证我们的测试框架

### 4.3 任务清单

#### 4.3.1 数据结构定义

**ncq.hpp**:

```cpp
#ifndef LSCQ_NCQ_HPP
#define LSCQ_NCQ_HPP

#include "lscq/config.hpp"
#include "lscq/cas2.hpp"
#include <atomic>
#include <cstddef>

namespace lscq {

template<typename T = uint64_t>
class NCQ {
public:
    static constexpr size_t SCQSIZE = config::DEFAULT_SCQSIZE;

    NCQ();
    ~NCQ();

    // 禁止拷贝和移动
    NCQ(const NCQ&) = delete;
    NCQ& operator=(const NCQ&) = delete;

    void enqueue(T index);
    T dequeue();  // 返回特殊值表示空

    bool is_empty() const;

private:
    struct alignas(16) Entry {
        uint64_t cycle;
        T index;
    };

    Entry* entries_;
    alignas(64) std::atomic<uint64_t> head_;
    alignas(64) std::atomic<uint64_t> tail_;

    size_t cache_remap(size_t idx) const;
};

}  // namespace lscq

#endif  // LSCQ_NCQ_HPP
```

#### 4.3.2 核心算法实现

**ncq.cpp** (基于论文Figure 5):

```cpp
#include "lscq/ncq.hpp"
#include <new>

namespace lscq {

template<typename T>
NCQ<T>::NCQ() : head_(SCQSIZE), tail_(SCQSIZE) {
    // 分配对齐的内存
    entries_ = static_cast<Entry*>(
        aligned_alloc(64, sizeof(Entry) * SCQSIZE)
    );

    // 初始化所有entry
    for (size_t i = 0; i < SCQSIZE; ++i) {
        entries_[i].cycle = 0;
        entries_[i].index = 0;
    }
}

template<typename T>
NCQ<T>::~NCQ() {
    free(entries_);
}

template<typename T>
void NCQ<T>::enqueue(T index) {
    while (true) {
        uint64_t t = tail_.load(std::memory_order_acquire);
        size_t j = cache_remap(t % SCQSIZE);

        Entry ent = entries_[j];  // 原子加载
        uint64_t cycle_t = t / SCQSIZE;
        uint64_t cycle_e = ent.cycle;

        if (cycle_e == cycle_t) {
            // 帮助推进tail
            tail_.compare_exchange_weak(t, t + 1,
                                       std::memory_order_release,
                                       std::memory_order_relaxed);
            continue;
        }

        if (cycle_e + 1 != cycle_t) {
            continue;  // Tail已过期
        }

        // 尝试CAS插入
        Entry new_ent{cycle_t, index};
        Entry expected = ent;

        if (cas2(&entries_[j], expected, new_ent)) {
            // 成功，尝试推进tail
            tail_.compare_exchange_weak(t, t + 1,
                                       std::memory_order_release,
                                       std::memory_order_relaxed);
            return;
        }
    }
}

template<typename T>
T NCQ<T>::dequeue() {
    while (true) {
        uint64_t h = head_.load(std::memory_order_acquire);
        size_t j = cache_remap(h % SCQSIZE);

        Entry ent = entries_[j];
        uint64_t cycle_h = h / SCQSIZE;
        uint64_t cycle_e = ent.cycle;

        if (cycle_e != cycle_h) {
            if (cycle_e + 1 == cycle_h) {
                return T(-1);  // 空队列
            }
            continue;  // Head已过期
        }

        // 尝试推进head
        if (head_.compare_exchange_weak(h, h + 1,
                                       std::memory_order_acq_rel,
                                       std::memory_order_acquire)) {
            return ent.index;
        }
    }
}

template<typename T>
size_t NCQ<T>::cache_remap(size_t idx) const {
    constexpr size_t ENTRIES_PER_LINE = 4;  // 64 / 16 = 4
    size_t line = idx / ENTRIES_PER_LINE;
    size_t offset = idx % ENTRIES_PER_LINE;
    return (offset * (SCQSIZE / ENTRIES_PER_LINE)) + line;
}

template<typename T>
bool NCQ<T>::is_empty() const {
    return head_.load() >= tail_.load();
}

// 显式实例化
template class NCQ<uint64_t>;
template class NCQ<uint32_t>;

}  // namespace lscq
```

#### 4.3.3 单元测试

**test_ncq.cpp**:

```cpp
#include <gtest/gtest.h>
#include "lscq/ncq.hpp"
#include <thread>
#include <vector>
#include <algorithm>

using namespace lscq;

TEST(NCQTest, BasicEnqueueDequeue) {
    NCQ<uint64_t> queue;

    queue.enqueue(42);
    queue.enqueue(100);

    EXPECT_EQ(queue.dequeue(), 42);
    EXPECT_EQ(queue.dequeue(), 100);
    EXPECT_EQ(queue.dequeue(), uint64_t(-1));  // 空队列
}

TEST(NCQTest, FIFO_Order) {
    NCQ<uint64_t> queue;

    for (uint64_t i = 0; i < 1000; ++i) {
        queue.enqueue(i);
    }

    for (uint64_t i = 0; i < 1000; ++i) {
        EXPECT_EQ(queue.dequeue(), i);
    }
}

TEST(NCQTest, ConcurrentEnqueue) {
    constexpr int NUM_THREADS = 8;
    constexpr int ITEMS_PER_THREAD = 1000;

    NCQ<uint64_t> queue;

    auto worker = [&](int thread_id) {
        for (int i = 0; i < ITEMS_PER_THREAD; ++i) {
            queue.enqueue(thread_id * ITEMS_PER_THREAD + i);
        }
    };

    std::vector<std::thread> threads;
    for (int i = 0; i < NUM_THREADS; ++i) {
        threads.emplace_back(worker, i);
    }

    for (auto& t : threads) {
        t.join();
    }

    // 验证所有元素都被插入
    std::vector<uint64_t> results;
    uint64_t val;
    while ((val = queue.dequeue()) != uint64_t(-1)) {
        results.push_back(val);
    }

    EXPECT_EQ(results.size(), NUM_THREADS * ITEMS_PER_THREAD);

    // 验证无重复
    std::sort(results.begin(), results.end());
    auto it = std::unique(results.begin(), results.end());
    EXPECT_EQ(it, results.end());
}

TEST(NCQTest, ConcurrentEnqueueDequeue) {
    constexpr int NUM_PRODUCERS = 4;
    constexpr int NUM_CONSUMERS = 4;
    constexpr int ITEMS_PER_PRODUCER = 10000;

    NCQ<uint64_t> queue;
    std::atomic<int> enqueued{0};
    std::atomic<int> dequeued{0};

    auto producer = [&](int thread_id) {
        for (int i = 0; i < ITEMS_PER_PRODUCER; ++i) {
            queue.enqueue(thread_id * ITEMS_PER_PRODUCER + i);
            enqueued.fetch_add(1);
        }
    };

    auto consumer = [&]() {
        uint64_t val;
        while (dequeued.load() < NUM_PRODUCERS * ITEMS_PER_PRODUCER) {
            val = queue.dequeue();
            if (val != uint64_t(-1)) {
                dequeued.fetch_add(1);
            } else {
                std::this_thread::yield();
            }
        }
    };

    std::vector<std::thread> threads;

    // 启动生产者
    for (int i = 0; i < NUM_PRODUCERS; ++i) {
        threads.emplace_back(producer, i);
    }

    // 启动消费者
    for (int i = 0; i < NUM_CONSUMERS; ++i) {
        threads.emplace_back(consumer);
    }

    for (auto& t : threads) {
        t.join();
    }

    EXPECT_EQ(dequeued.load(), NUM_PRODUCERS * ITEMS_PER_PRODUCER);
}
```

#### 4.3.4 简单Benchmark

**benchmark_ncq.cpp**:

```cpp
#include <benchmark/benchmark.h>
#include "lscq/ncq.hpp"
#include <thread>
#include <vector>

using namespace lscq;

static void BM_NCQ_EnqueueDequeue_Pair(benchmark::State& state) {
    NCQ<uint64_t> queue;
    int thread_count = state.range(0);

    auto worker = [&]() {
        for (auto _ : state) {
            queue.enqueue(42);
            benchmark::DoNotOptimize(queue.dequeue());
        }
    };

    std::vector<std::thread> threads;
    for (int i = 0; i < thread_count; ++i) {
        threads.emplace_back(worker);
    }

    for (auto& t : threads) {
        t.join();
    }
}

BENCHMARK(BM_NCQ_EnqueueDequeue_Pair)->Arg(1)->Arg(2)->Arg(4)->Arg(8)->Arg(16);

BENCHMARK_MAIN();
```

### 4.4 可交付成果

- [ ] NCQ完整实现 (hpp + cpp)
- [ ] NCQ单元测试全部通过
- [ ] 基础benchmark可运行
- [ ] API文档初稿

### 4.5 验收标准

1. ✅ 所有单元测试通过
2. ✅ 并发测试无data race (ThreadSanitizer)
3. ✅ Benchmark结果与预期一致
4. ✅ 代码覆盖率 > 85%

---

## 5. Phase 3: SCQ核心实现

### 5.1 目标

实现论文的核心算法SCQ，包括threshold机制、cache remap和catchup优化。

### 5.2 任务清单

#### 5.2.1 核心数据结构

- [ ] Entry结构 (cycle + issafe + index)
- [ ] SCQ类定义
- [ ] Threshold机制
- [ ] Cache remap函数

#### 5.2.2 核心算法

- [ ] Enqueue实现
- [ ] Dequeue实现
- [ ] Catchup机制
- [ ] Atomic_OR优化

#### 5.2.3 测试与验证

- [ ] 正确性测试 (单线程)
- [ ] 并发测试 (多线程)
- [ ] Livelock测试
- [ ] Threshold机制验证

#### 5.2.4 Benchmark

- [ ] 与NCQ对比
- [ ] 不同线程数的性能
- [ ] Cache remap效果验证

### 5.3 可交付成果

- [ ] SCQ完整实现
- [ ] 完整的单元测试套件
- [ ] 性能benchmark报告
- [ ] SCQ vs NCQ性能对比

### 5.4 验收标准

1. ✅ 所有测试通过 (含livelock测试)
2. ✅ 性能达到论文水平的80%以上
3. ✅ Threshold机制工作正常
4. ✅ 代码覆盖率 > 90%

---

## 6. Phase 4: 双字宽CAS扩展 (SCQP)

### 6.1 目标

实现直接存储指针的SCQP版本，适用于x86-64和ARM64平台。

### 6.2 任务清单

- [ ] SCQP数据结构定义
- [ ] Threshold调整为4n-1
- [ ] "队列满"检测实现
- [ ] 与SCQ性能对比
- [ ] 平台检测和条件编译

### 6.3 可交付成果

- [ ] SCQP完整实现
- [ ] 性能对比报告
- [ ] 平台兼容性矩阵

### 6.4 验收标准

1. ✅ x86-64上性能优于SCQ
2. ✅ ARM64上正常工作
3. ✅ Fallback到SCQ正常

---

## 7. Phase 5: LSCQ无界队列

### 7.1 目标

实现基于SCQ链表的无界队列LSCQ，包括内存回收机制。

### 7.2 任务清单

#### 7.2.1 核心实现

- [ ] SCQNode结构
- [ ] 链表操作
- [ ] Finalize机制
- [ ] Epoch-based回收

#### 7.2.2 测试

- [ ] 容量测试 (百万级元素)
- [ ] 内存泄漏测试
- [ ] 压力测试

### 7.3 可交付成果

- [ ] LSCQ完整实现
- [ ] 内存回收验证
- [ ] 压力测试报告

### 7.4 验收标准

1. ✅ 无内存泄漏
2. ✅ 支持任意数量元素
3. ✅ 性能满足要求

---

## 8. Phase 6: 优化与多平台支持

### 8.1 目标

性能调优、多平台支持、文档完善。

### 8.2 任务清单

- [ ] 性能profiling和优化
- [ ] ARM64移植和测试
- [ ] PowerPC fallback验证
- [ ] 完整API文档
- [ ] 使用示例和教程

### 8.3 可交付成果

- [ ] 优化后的代码
- [ ] 多平台CI
- [ ] 完整文档

---

## 9. 里程碑时间线

```
Week 1-2:   Phase 1 - 基础设施搭建
Week 3:     Phase 2 - NCQ实现
Week 4-6:   Phase 3 - SCQ核心
Week 7:     Phase 4 - SCQP扩展
Week 8-9:   Phase 5 - LSCQ实现
Week 10-13: Phase 6 - 优化与多平台
```

---

## 10. 持续集成计划

### 10.1 CI Pipeline

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        compiler: [gcc, clang, msvc]
        build_type: [Debug, Release]

    steps:
      - uses: actions/checkout@v3
      - name: Configure
        run: cmake -B build -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
      - name: Build
        run: cmake --build build
      - name: Test
        run: ctest --test-dir build --output-on-failure
      - name: Benchmark
        run: ./build/benchmark/benchmark_all --benchmark_min_time=0.1
```

### 10.2 代码质量检查

- Clang-Tidy
- Clang-Format
- CppCheck
- ThreadSanitizer
- AddressSanitizer

---

## 11. 文档计划

| 文档 | 状态 | 负责阶段 |
|------|------|----------|
| 技术实现思路 | ✅ 完成 | Phase 0 |
| 分段开发计划 | ✅ 完成 | Phase 0 |
| 性能验证方案 | ⏳ 待完成 | Phase 0 |
| API参考手册 | ⏳ 待完成 | Phase 2-5 |
| 使用教程 | ⏳ 待完成 | Phase 6 |
| 性能报告 | ⏳ 待完成 | Phase 6 |

---

**文档变更记录**:

| 版本 | 日期 | 作者 | 变更内容 |
|------|------|------|----------|
| v1.0 | 2026-01-17 | Team | 初始版本，定义6个开发阶段 |
